import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib import animation

class PID():
    def __init__(self, kp, kd, ki):
        self.kp = kp
        self.kd = kd
        self.ki = ki
        self.cum_angle_error = 0
        self.prev_angle_error = 0

    def adjust(self, current_pose, goal_pose):
        dist_error = np.sqrt((current_pose.x - goal_pose.x)**2 + (current_pose.y - goal_pose.y)**2)
        desired_angle = np.arctan2((goal_pose.y - current_pose.y),(goal_pose.x - current_pose.x))
        angle_error = desired_angle - current_pose.theta
        angle_error = (angle_error + np.pi) % (2 * np.pi) - np.pi #wrap angle between -pi to pi /(-180 to 180)deg
        beta = goal_pose.theta - current_pose.theta
        self.cum_angle_error += angle_error * dt
        d_error = (angle_error - self.prev_angle_error)/dt
        if (dist_error < 0.05):
            v = 0
            beta = (goal_pose.theta - current_pose.theta + np.pi) % (2 * np.pi) - np.pi
            w = 0.5 * beta
        else:
            w = (self.kp * angle_error) + (self.ki * self.cum_angle_error) + (self.kd * d_error) + (0.2 * beta)
            v = (0.1*dist_error*np.cos(angle_error))
            v = max(0, min(v, 3))
        self.prev_angle_error = angle_error
        return w, v
        

class Pose:
    def __init__(self, x=0.0, y=0.0, theta=0.0):
        self.x = x
        self.y = y
        self.theta = theta

    def positional_error(self, other):
        dx = other.x - self.x
        dy = other.y - self.y
        error_vector = (dx, dy)
        error_magnitude = math.hypot(dx, dy)
        return error_vector, error_magnitude
    
    def heading_error(self, other):
        # Wrap self.theta and other.theta
        theta_self = (self.theta + np.pi) % (2 * np.pi) - np.pi
        theta_other = (other.theta + np.pi) % (2 * np.pi) - np.pi
        
        dtheta = theta_other - theta_self
        dtheta = (dtheta + np.pi) % (2 * np.pi) - np.pi  # wrap difference too
        return abs(dtheta)


# Simulation stuff
dt = 0.1
T = 1000
steps = int(T/dt)

#Robot state variables
x, y, theta = 0.0, 0.0, 0.0

#Controls
#v = 0.2  # m/s
#w = 0.2  # rad/s

#Robot path
xs, ys, thetas = [], [], []
current_pose = Pose(0.0, 0.0, 0.0)
goal_pose = Pose(-5.0, -5.0, 0.0)


#Controller
pid = PID(kp=0.7, kd=0.05, ki=0.01)

for step in range(steps):
    # Adjust step
    w, v = pid.adjust(current_pose, goal_pose)
    # Kinematics
    x += v * np.cos(theta) * dt
    y += v * np.sin(theta) * dt
    theta += w * dt

    current_pose.x = x
    current_pose.y = y
    current_pose.theta = theta

    xs.append(x)
    ys.append(y)
    thetas.append(theta)

    err_vec, err_mag = current_pose.positional_error(goal_pose)
    dtheta = current_pose.heading_error(goal_pose)

    if ((err_mag < 0.05)):
        if dtheta < 0.01:
            print(dtheta)
            break 

# --- Animation ---
fig, ax = plt.subplots(figsize=(6,6))
ax.set_xlim(min(xs)-1, max(xs)+1)
ax.set_ylim(min(ys)-1, max(ys)+1)
ax.set_xlabel("X [m]")
ax.set_ylabel("Y [m]")
ax.set_title("Robot Trajectory Animation")
ax.plot(goal_pose.x, goal_pose.y, "go", label="Goal")

# Robot arrow
robot_arrow = ax.quiver(xs[0], ys[0], np.cos(theta), np.sin(theta), scale=6, color="r")
path_line, = ax.plot([], [], 'b-', lw=2, label="Trajectory")
ax.legend()

def animate(i):
    path_line.set_data(xs[:i+1], ys[:i+1])
    robot_arrow.set_offsets([xs[i], ys[i]])
    robot_arrow.set_UVC(np.cos(theta if i == len(thetas)-1 else thetas[i]), 
                        np.sin(theta if i == len(thetas)-1 else thetas[i]))
    return path_line, robot_arrow

ani = animation.FuncAnimation(fig, animate, frames=len(xs), interval=dt*1000/40, blit=True)
plt.show()

# Plotting
# plt.figure(figsize=(6,6))
# plt.plot(xs, ys, label="Trajectory")
# plt.quiver(xs[-1], ys[-1], np.cos(theta), np.sin(theta), scale=6, color="r")
# plt.quiver(goal_pose.x, goal_pose.y, np.cos(goal_pose.theta), np.sin(goal_pose.theta), scale=6, color="g")
# plt.xlabel("X [m]")
# plt.ylabel("Y [m]")
# plt.axis("equal")
# plt.legend()
# plt.show()